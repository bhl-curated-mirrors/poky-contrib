From 9bf14ede2ad67178cc54e29e9fe9ccad7269a462 Mon Sep 17 00:00:00 2001
From: Juro Bystricky <juro.bystricky@intel.com>
Date: Mon, 27 Feb 2017 16:21:47 -0800
Subject: [PATCH] altera_10m_50: New devices

Signed-off-by: Juro Bystricky <juro.bystricky@intel.com>
---
 hw/nios2/Makefile.objs         |   2 +
 hw/nios2/altera_10m50_device.c | 314 +++++++++++++++++++++++++++++++++++++++++
 hw/nios2/altera_10m50_zephyr.c | 148 +++++++++++++++++++
 3 files changed, 464 insertions(+)
 create mode 100644 hw/nios2/altera_10m50_device.c
 create mode 100644 hw/nios2/altera_10m50_zephyr.c

diff --git a/hw/nios2/Makefile.objs b/hw/nios2/Makefile.objs
index 6b5c421..c24a3de 100644
--- a/hw/nios2/Makefile.objs
+++ b/hw/nios2/Makefile.objs
@@ -1 +1,3 @@
 obj-y = boot.o cpu_pic.o 10m50_devboard.o
+obj-y += altera_10m50_zephyr.o cpu_pic.o
+obj-y += altera_10m50_device.o cpu_pic.o boot.o
diff --git a/hw/nios2/altera_10m50_device.c b/hw/nios2/altera_10m50_device.c
new file mode 100644
index 0000000..c86091f
--- /dev/null
+++ b/hw/nios2/altera_10m50_device.c
@@ -0,0 +1,314 @@
+/*
+ * Flexible model of nios2 designs that use a device-tree to determine
+ * the hardware configuration.
+ *
+ * Copyright (c) 2012 Chris Wulff <crwulff@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see
+ * <http://www.gnu.org/licenses/lgpl-2.1.html>
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu/error-report.h"
+#include "cpu.h"
+#include "hw/sysbus.h"
+#include "hw/hw.h"
+
+#include "hw/char/serial.h"
+#include "hw/block/flash.h"
+#include "sysemu/sysemu.h"
+#include "hw/devices.h"
+#include "hw/boards.h"
+#include "sysemu/device_tree.h"
+#include "hw/loader.h"
+#include "elf.h"
+#include "qemu/log.h"
+#include "exec/address-spaces.h"
+#include "sysemu/blockdev.h"
+#include "qapi/qmp/qerror.h"
+#include "hw/char/altera_juart.h"
+#include <libfdt.h>
+
+#include "boot.h"
+
+#define DEBUG
+
+#ifdef DEBUG
+# define DPRINTF(format, ...)     printf(format, ## __VA_ARGS__)
+#else
+# define DPRINTF(format, ...)     do { } while (0)
+#endif
+
+#define BINARY_DEVICE_TREE_FILE "10m50-devboard.dtb"
+
+static void *altera_load_device_tree(const char *dtb_filename, int *fdt_size)
+{
+    void *fdt = NULL;
+
+    if (dtb_filename) {
+        fdt = load_device_tree(dtb_filename, fdt_size);
+        if (!fdt) {
+            error_report("Error while loading device tree file '%s'",
+                dtb_filename);
+        }
+    } else {
+        DPRINTF("\ndtb: no DTB file specified!");
+    }
+
+    return fdt;
+}
+
+static inline DeviceState *altera_pic_init(Nios2CPU *cpu, qemu_irq cpu_irq)
+{
+    DeviceState *dev;
+    SysBusDevice *d;
+
+    dev = qdev_create(NULL, "altera,iic");
+    qdev_prop_set_ptr(dev, "cpu", cpu);
+    qdev_init_nofail(dev);
+    d = SYS_BUS_DEVICE(dev);
+    sysbus_connect_irq(d, 0, cpu_irq);
+
+    return dev;
+}
+
+static int find_compatible_controller(void *fdt, int node,
+            const char *compat, hwaddr *addr, int *irq, uint32_t * freq)
+{
+    node = fdt_node_offset_by_compatible(fdt, node, compat);
+    if (node >= 0) {
+        int len;
+        #ifdef DEBUG
+        DPRINTF("%s: %s\n", __func__, compat);
+        const char *name = fdt_get_name(fdt, node, &len);
+        DPRINTF("\tcontroller: %s\n", name);
+        #endif
+        const int *cell = fdt_getprop_w(fdt, node, "interrupts", &len);
+        if (cell && len >= sizeof(int)) {
+            *irq = fdt32_to_cpu(cell[0]);
+            DPRINTF("\tirq: %d\n", *irq);
+        } else {
+            goto Barf;
+        }
+
+        const int *reg = fdt_getprop(fdt, node, "reg", &len);
+        if (reg && len >= sizeof(int)) {
+            *addr = fdt32_to_cpu(reg[0]);
+            DPRINTF("\treg: %lx [len:%d]\n", *addr, len);
+        } else {
+            goto Barf;
+        }
+
+        if (freq != NULL) {
+            const int *fr = fdt_getprop(fdt, node, "clock-frequency", &len);
+            if (fr && len >= sizeof(int)) {
+                *freq = fdt32_to_cpu(fr[0]);
+            DPRINTF("\tfrequency: %d [len:%d]\n", *freq, len);
+            } else {
+                goto Barf;
+            }
+        }
+    }
+    return node;
+Barf:
+    fprintf(stderr, "Error: failed to parse \"%s\"\n", compat);
+    exit(1);
+}
+
+static void init_cpu_from_devtree(void *fdt, Nios2CPU *cpu)
+{
+    cpu->reset_addr =
+        qemu_fdt_getprop_cell(fdt, "/cpus/cpu", "altr,reset-addr",
+                              NULL, &error_fatal);
+
+    cpu->exception_addr =
+        qemu_fdt_getprop_cell(fdt, "/cpus/cpu", "altr,exception-addr",
+                              NULL, &error_fatal);
+
+    cpu->fast_tlb_miss_addr =
+        qemu_fdt_getprop_cell(fdt, "/cpus/cpu", "altr,fast-tlb-miss-addr",
+                              NULL, &error_fatal);
+
+    DPRINTF("\n\tcpu->reset_addr: \t\t%0x\n", cpu->reset_addr);
+    DPRINTF("\tcpu->exception_addr: \t\t%0x\n", cpu->exception_addr);
+    DPRINTF("\tcpu->fast_tlb_miss_addr: \t%0x\n\n", cpu->fast_tlb_miss_addr);
+
+    cpu->pid_num_bits = qemu_fdt_getprop_cell(fdt, "/cpus/cpu",
+                                              "altr,pid-num-bits",
+                                              NULL, &error_fatal);
+    cpu->tlb_num_ways = qemu_fdt_getprop_cell(fdt, "/cpus/cpu",
+                                              "altr,tlb-num-ways",
+                                               NULL, &error_fatal);
+    cpu->tlb_num_entries = qemu_fdt_getprop_cell(fdt, "/cpus/cpu",
+                                                 "altr,tlb-num-entries",
+                                                 NULL, &error_fatal);
+}
+
+static void altera_timer_create(const hwaddr addr, qemu_irq irq, uint32_t freq)
+{
+    DeviceState *dev;
+
+    dev = qdev_create(NULL, "ALTR.timer");
+    qdev_prop_set_uint32(dev, "clock-frequency", freq);
+    qdev_init_nofail(dev);
+    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, addr);
+    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, irq);
+}
+
+#define MEMORY_BASEADDR 0x08000000
+#define LMB_BRAM_SIZE   (0x1024 * 4)
+
+static void altera_10m50_init_common(Nios2CPU *cpu, MachineState *machine)
+{
+    ram_addr_t ram_size = machine->ram_size;
+    const char *kernel_filename;
+    const char *kernel_cmdline;
+    DeviceState *dev;
+    MemoryRegion *address_space_mem = get_system_memory();
+    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);
+    const char *dtb_arg;
+    int i, interrupt, node;
+    hwaddr base, ddr_base = MEMORY_BASEADDR;
+    qemu_irq *cpu_irq, irq[32];
+    QemuOpts *machine_opts;
+    int fdt_size;
+    const char *dtb_filename;
+
+    machine_opts = qemu_get_machine_opts();
+    kernel_filename = qemu_opt_get(machine_opts, "kernel");
+    kernel_cmdline = qemu_opt_get(machine_opts, "append");
+
+    dtb_arg = qemu_opt_get(machine_opts, "dtb");
+    if (dtb_arg) { /* Preference a -dtb argument */
+        dtb_filename = dtb_arg;
+    } else {
+        dtb_filename = BINARY_DEVICE_TREE_FILE;
+    }
+
+    DPRINTF("\n\tkernel_filename: %s\n", kernel_filename);
+    DPRINTF("\tinitrd: %s\n", machine->initrd_filename);
+    DPRINTF("\tkernel_cmdline:  %s\n", kernel_cmdline);
+    DPRINTF("\tdtb filename:  %s\n", dtb_filename);
+    DPRINTF("\tmmu_present:  %d\n\n", cpu->mmu_present);
+
+    void *fdt = altera_load_device_tree(dtb_filename, &fdt_size);
+    if (!fdt) {
+        return;
+    }
+
+    object_property_set_bool(OBJECT(cpu), true, "realized", &error_abort);
+
+    MemoryRegion *phys_lmb_bram = g_new(MemoryRegion, 1);
+    MemoryRegion *phys_lmb_bram_alias = g_new(MemoryRegion, 1);
+    MemoryRegion *phys_ram_alias = g_new(MemoryRegion, 1);
+
+    memory_region_init_ram(phys_lmb_bram, NULL, "nios2.lmb_bram",
+                                        LMB_BRAM_SIZE, &error_fatal);
+    memory_region_init_alias(phys_lmb_bram_alias, NULL,
+                            "nios2.lmb_bram.alias", phys_lmb_bram, 0,
+                            LMB_BRAM_SIZE);
+    vmstate_register_ram_global(phys_lmb_bram);
+    memory_region_add_subregion(address_space_mem, 0x00000000, phys_lmb_bram);
+    memory_region_add_subregion(address_space_mem, 0xc0000000, phys_lmb_bram_alias);
+
+    memory_region_init_ram(phys_ram, NULL, "nios2.ram", ram_size, &error_fatal);
+    vmstate_register_ram_global(phys_ram);
+    memory_region_add_subregion(address_space_mem, ddr_base, phys_ram);
+    memory_region_init_alias(phys_ram_alias, NULL, "nios2.ram.mirror",
+                    phys_ram, 0, ram_size);
+    memory_region_add_subregion(address_space_mem, ddr_base + 0xc0000000,
+                    phys_ram_alias);
+
+#ifdef GOOD_STUFF
+    /* create irq lines */
+    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, cpu, 2);
+    env->pic_state = altera_pic_init(cpu, *cpu_irq);
+
+    /* Nios2 IIC has 32 interrupt-request inputs*/
+    for (i = 0; i < 32; i++) {
+        irq[i] = qdev_get_gpio_in(env->pic_state, i);
+    }
+#else
+    /* Register: CPU interrupt controller (PIC) */
+    cpu_irq = nios2_cpu_pic_init(cpu);
+    /* Register: Internal Interrupt Controller (IIC) */
+    dev = qdev_create(NULL, "altera,iic");
+    qdev_prop_set_ptr(dev, "cpu", cpu);
+    qdev_init_nofail(dev);
+    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, cpu_irq[0]);
+    for (i = 0; i < 32; i++) {
+        irq[i] = qdev_get_gpio_in(dev, i);
+    }
+#endif
+
+    find_compatible_controller(fdt, -1, "altr,juart-1.0", &base,
+                               &interrupt, NULL);
+    altera_juart_create(1, base | 0xe0000000, irq[interrupt], 16);
+
+    find_compatible_controller(fdt, -1, "altr,16550-FIFO32", &base,
+                               &interrupt, NULL);
+    serial_mm_init(address_space_mem, base | 0xe0000000, 2, irq[interrupt], 115200,
+                   serial_hds[0], DEVICE_NATIVE_ENDIAN);
+
+    /* Find all timers... */
+    node = -1;
+    do {
+        uint32_t frequency;
+        node = find_compatible_controller(fdt, node, "altr,timer-1.0",
+                                          &base, &interrupt, &frequency);
+        if (node >= 0) {
+            altera_timer_create(base | 0xe0000000, irq[interrupt], frequency);
+        }
+    } while (node > 0);
+
+    init_cpu_from_devtree(fdt, cpu);
+    nios2_load_kernel(cpu, MEMORY_BASEADDR, ram_size, machine->initrd_filename,
+                      BINARY_DEVICE_TREE_FILE, NULL);
+}
+
+static void altera_10m50_init_no_mmu(MachineState *machine)
+{
+    Nios2CPU *cpu = NIOS2_CPU(object_new(TYPE_NIOS2_CPU));
+    object_property_set_bool(OBJECT(cpu), false, "mmu_present",
+                             &error_abort);
+    altera_10m50_init_common(cpu, machine);
+}
+
+static void altera_10m50_init_mmu(MachineState *machine)
+{
+    Nios2CPU *cpu = NIOS2_CPU(object_new(TYPE_NIOS2_CPU));
+    object_property_set_bool(OBJECT(cpu), true, "mmu_present",
+                             &error_abort);
+    altera_10m50_init_common(cpu, machine);
+}
+
+static void altera_10m50_no_mmu_init(MachineClass *mc)
+{
+    mc->desc = "Altera 10m50 device without MMU.";
+    mc->init = altera_10m50_init_no_mmu;
+    mc->is_default = 0;
+}
+
+static void altera_10m50_mmu_init(MachineClass *mc)
+{
+    mc->desc = "Altera 10m50 device with MMU.";
+    mc->init = altera_10m50_init_mmu;
+    mc->is_default = 0;
+}
+
+DEFINE_MACHINE("altera_10m50_no_mmu", altera_10m50_no_mmu_init)
+DEFINE_MACHINE("altera_10m50_mmu", altera_10m50_mmu_init)
+
+
diff --git a/hw/nios2/altera_10m50_zephyr.c b/hw/nios2/altera_10m50_zephyr.c
new file mode 100644
index 0000000..78ea9f9
--- /dev/null
+++ b/hw/nios2/altera_10m50_zephyr.c
@@ -0,0 +1,148 @@
+/*
+ * Altera Nios2 Zephyr board emulation.
+ *
+ * Copyright (c) 2016-2017 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "cpu.h"
+#include "hw/sysbus.h"
+#include "hw/hw.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "hw/loader.h"
+#include "elf.h"
+#include "exec/address-spaces.h"
+#include "hw/char/altera_juart.h"
+
+static struct {
+    uint32_t bootstrap_pc;
+} boot_info_zephyr;
+
+static void main_cpu_reset(void *opaque)
+{
+    Nios2CPU *cpu = opaque;
+    CPUNios2State *env = &cpu->env;
+
+    cpu_reset(CPU(cpu));
+    env->regs[R_PC] = boot_info_zephyr.bootstrap_pc;
+}
+
+#define ROM_BASE 0x00000000
+#define ROM_SIZE 32
+
+#define RAM_BASE 0x400000
+#define RAM_SIZE 262144
+
+#define TIMER_0_BASE 0x440200
+#define TIMER_0_FREQ 50000000
+#define TIMER_0_IRQ 2
+
+#define JTAG_UART_0_BASE 0x201000
+#define JTAG_UART_0_IRQ  0
+
+#define ALT_CPU_EXCEPTION_ADDR  0x00400020
+#define ALT_CPU_RESET_ADDR      0x00000000
+
+static void altera_timer_create(const hwaddr addr, qemu_irq irq, uint32_t frequency)
+{
+    DeviceState *dev;
+
+    dev = qdev_create(NULL, "ALTR.timer");
+    qdev_prop_set_uint32(dev, "clock-frequency", frequency);
+    qdev_init_nofail(dev);
+    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, addr);
+    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, irq);
+}
+
+static void altera_10m50_zephyr_init(MachineState *machine)
+{
+    const char *kernel_filename;
+    MemoryRegion *sysmem = get_system_memory();
+    Nios2CPU *cpu;
+    int i;
+    QemuOpts *machine_opts;
+    int kernel_size;
+    qemu_irq irq[32];
+    qemu_irq *cpu_irq;
+    DeviceState *dev;
+
+    MemoryRegion *rom = g_new(MemoryRegion, 1);
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+
+    cpu = NIOS2_CPU(object_new(TYPE_NIOS2_CPU));
+    object_property_set_bool(OBJECT(cpu), false, "mmu_present",
+                             &error_abort);
+
+    object_property_set_bool(OBJECT(cpu), true, "realized", &error_abort);
+    machine_opts = qemu_get_machine_opts();
+    kernel_filename = qemu_opt_get(machine_opts, "kernel");
+
+    memory_region_init_ram(rom, NULL, "nios2.rom", ROM_SIZE, &error_fatal);
+    vmstate_register_ram_global(rom);
+    memory_region_set_readonly(rom, true);
+    memory_region_add_subregion(sysmem, ROM_BASE, rom);
+
+    memory_region_init_ram(ram, NULL, "nios2.ram", RAM_SIZE, &error_fatal);
+    vmstate_register_ram_global(ram);
+    memory_region_add_subregion(sysmem, RAM_BASE, ram);
+
+    cpu->reset_addr = ALT_CPU_RESET_ADDR;
+    cpu->exception_addr = ALT_CPU_EXCEPTION_ADDR;
+    cpu->fast_tlb_miss_addr = 0;
+
+    /* Register: CPU interrupt controller (PIC) */
+    cpu_irq = nios2_cpu_pic_init(cpu);
+
+    /* Register: Internal Interrupt Controller (IIC) */
+    dev = qdev_create(NULL, "altera,iic");
+    qdev_prop_set_ptr(dev, "cpu", cpu);
+    qdev_init_nofail(dev);
+    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, cpu_irq[0]);
+    for (i = 0; i < 32; i++) {
+        irq[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    altera_juart_create(0, JTAG_UART_0_BASE, irq[JTAG_UART_0_IRQ], 16);
+    altera_timer_create(TIMER_0_BASE, irq[TIMER_0_IRQ], TIMER_0_FREQ);
+
+    if (kernel_filename) {
+        uint64_t entry;
+
+        /* Boots a Zephyr elf binary. */
+        kernel_size = load_elf(kernel_filename, NULL, NULL,
+                               &entry, NULL, NULL,
+                               0, EM_ALTERA_NIOS2, 0, 0);
+
+        boot_info_zephyr.bootstrap_pc = entry;
+
+        /* Not an ELF image, bail out. */
+        if (kernel_size < 0) {
+            fprintf(stderr, "qemu: could not load kernel '%s'\n",
+                    kernel_filename);
+            exit(1);
+        }
+    }
+
+    qemu_register_reset(main_cpu_reset, cpu);
+}
+
+static void altera_10m50_zephyr_machine_init(MachineClass *mc)
+{
+    mc->desc = "Altera 10m50 for Zephyr.";
+    mc->init = altera_10m50_zephyr_init;
+    mc->is_default = 0;
+}
+
+DEFINE_MACHINE("altera_10m50_zephyr", altera_10m50_zephyr_machine_init)
+
-- 
2.7.4

