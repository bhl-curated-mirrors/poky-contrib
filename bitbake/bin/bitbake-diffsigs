#!/usr/bin/env python3

# bitbake-diffsigs
# BitBake task signature data comparison utility
#
# Copyright (C) 2012-2013, 2017 Intel Corporation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import os
import sys
import warnings
import fnmatch
import argparse
import logging
import pickle

sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(sys.argv[0])), 'lib'))

import bb.tinfoil
import bb.siggen

def logger_create(name, output=sys.stderr):
    logger = logging.getLogger(name)
    console = logging.StreamHandler(output)
    format = bb.msg.BBLogFormatter("%(levelname)s: %(message)s")
    if output.isatty():
        format.enable_color()
    console.setFormatter(format)
    logger.addHandler(console)
    logger.setLevel(logging.INFO)
    return logger

logger = logger_create('bitbake-diffsigs')

def find_compare_task(bbhandler, pn, taskname, sig1=None, sig2=None):
    """ Find the most recent signature files for the specified PN/task and compare them """

    def get_hashval(siginfo):
        if siginfo.endswith('.siginfo'):
            return siginfo.rpartition(':')[2].partition('_')[0]
        else:
            return siginfo.rpartition('.')[2]

    if not hasattr(bb.siggen, 'find_siginfo'):
        logger.error('Metadata does not support finding signature data files')
        sys.exit(1)

    if not taskname.startswith('do_'):
        taskname = 'do_%s' % taskname

    if sig1 and sig2:
        sigfiles = bb.siggen.find_siginfo(pn, taskname, [sig1, sig2], bbhandler.config_data)
        if len(sigfiles) == 0:
            logger.error('No sigdata files found matching %s %s matching either %s or %s' % (pn, taskname, sig1, sig2))
            sys.exit(1)
        elif not sig1 in sigfiles:
            logger.error('No sigdata files found matching %s %s with signature %s' % (pn, taskname, sig1))
            sys.exit(1)
        elif not sig2 in sigfiles:
            logger.error('No sigdata files found matching %s %s with signature %s' % (pn, taskname, sig2))
            sys.exit(1)
        latestfiles = [sigfiles[sig1], sigfiles[sig2]]
    else:
        filedates = bb.siggen.find_siginfo(pn, taskname, None, bbhandler.config_data)
        latestfiles = sorted(filedates.keys(), key=lambda f: filedates[f])[-3:]
        if not latestfiles:
            logger.error('No sigdata files found matching %s %s' % (pn, taskname))
            sys.exit(1)
        elif len(latestfiles) < 2:
            logger.error('Only one matching sigdata file found for the specified task (%s %s)' % (pn, taskname))
            sys.exit(1)
        else:
            # It's possible that latestfiles contain 3 elements and the first two have the same hash value.
            # In this case, we delete the second element.
            # The above case is actually the most common one. Because we may have sigdata file and siginfo
            # file having the same hash value. Comparing such two files makes no sense.
            if len(latestfiles) == 3:
                hash0 = get_hashval(latestfiles[0])
                hash1 = get_hashval(latestfiles[1])
                if hash0 == hash1:
                    latestfiles.pop(1)

    # Define recursion callback
    def recursecb(key, hash1, hash2):
        hashes = [hash1, hash2]
        hashfiles = bb.siggen.find_siginfo(key, None, hashes, bbhandler.config_data)

        recout = []
        if len(hashfiles) == 0:
            recout.append("Unable to find matching sigdata for %s with hashes %s or %s" % (key, hash1, hash2))
        elif not hash1 in hashfiles:
            recout.append("Unable to find matching sigdata for %s with hash %s" % (key, hash1))
        elif not hash2 in hashfiles:
            recout.append("Unable to find matching sigdata for %s with hash %s" % (key, hash2))
        else:
            out2 = bb.siggen.compare_sigfiles(hashfiles[hash1], hashfiles[hash2], recursecb)
            recout.extend(list('  ' + l for l in out2))

        return recout

    # Recurse into signature comparison
    output = bb.siggen.compare_sigfiles(latestfiles[0], latestfiles[1], recursecb)
    if output:
        print('\n'.join(output))
    sys.exit(0)



parser = argparse.ArgumentParser(
    description="Compares siginfo/sigdata files written out by BitBake",
    usage="""
  %(prog)s -t recipename taskname [-s fromsig tosig]
  %(prog)s sigdatafile1 sigdatafile2
  %(prog)s sigdatafile1""")

parser.add_argument("-t", "--task",
        help="find the signature data files for last two runs of the specified task and compare them",
        action="store", dest="taskargs", nargs=2, metavar=('recipename', 'taskname'))

parser.add_argument("-s", "--signature",
        help="specify the signatures to look for",
        action="store", dest="sigargs", nargs=2, metavar=('fromsig', 'tosig'))

parser.add_argument("sigdatafile1",
        help="First signature file to compare (or signature file to dump, if second not specified)",
        action="store", nargs='?')

parser.add_argument("sigdatafile2",
        help="Second signature file to compare",
        action="store", nargs='?')


options = parser.parse_args(sys.argv)

if options.taskargs:
    with bb.tinfoil.Tinfoil() as tinfoil:
        tinfoil.prepare(config_only=True)
        if options.sigargs:
            find_compare_task(tinfoil, options.taskargs[0], options.taskargs[1], options.sigargs[0], options.sigargs[1])
        else:
            find_compare_task(tinfoil, options.taskargs[0], options.taskargs[1])
else:
    try:
        if options.sigdatafile1 and options.sigdatafile2:
            output = bb.siggen.compare_sigfiles(options.sigdatafile1, options.sigdatafile2)
        elif options.sigdatafile1:
            output = bb.siggen.dump_sigfile(options.sigdatafile1)
    except IOError as e:
        logger.error(str(e))
        sys.exit(1)
    except (pickle.UnpicklingError, EOFError):
        logger.error('Invalid signature data - ensure you are specifying sigdata/siginfo files')
        sys.exit(1)

    if output:
        print('\n'.join(output))
